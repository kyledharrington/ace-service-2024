metadata:
  version: "1"
  dependencies:
    apps:
      - id: dynatrace.automations
        version: ^1.905.5
  inputs: []
workflow:
  title: Business Data Generator - Financial services - Account opening
  tasks:
    config:
      name: config
      description: Build a custom task running js Code
      action: dynatrace.automations:run-javascript
      input:
        script: >
          import { execution } from "@dynatrace-sdk/automation-utils"


          export default async function ({ execution_id }) {
            // NB - CURRENTLY ALL PIECES OF CONFIG ARE MANDATORY

            // If using the defaults that the generator comes with, set the below to true so that a default dashboard
            // is imported which shows several examples of visualisations.
            const EXAMPLE_DASHBOARD = true

            // A name that describes this business process - this will be used as the name for the Business Flow that
            // gets created, and also the dashboard if you choose to have it.
            const FLOW_NAME = "[FINANCIAL SERVICES] Account opening"

            // Name of the event.provider field that will be used. Events in the future will be stored in a provider
            // with ".temp" appended to the end.
            const EVENT_PROVIDER = "acme.bank"

            // Name of the correlation ID that will be added to each BizEvent, this will be the name
            // of the field that you see in the BizEvent.
            const CORRELATION_ID = "customer.id"

            // Steps you wish the process to have, the first field is the "pretty name", the
            // second is what the "event.type" in the BizEvent will be, and the numbers after it are:
            // First number: "Drop off" percentage. e.g. 5 = 5% of users will drop off.
            // Second number: Minimum time (in hours) for the step to take.
            // Third number: Maximum time (in hours) for the step to take.
            // N.B - So far only tested with processes taking up to 48 hours.
            // Boolean: Will this step "loop" and be repeated several times before the process continues?
            // Number: Max number of times this step should loop.
            // Note: Step 1 doesn't use any of the numbers and the last step cannot loop.
            const PROCESS_STEPS = [
              ["Online application", "online.application"],
              ["Documents checked", "documents.check", 5, 1, 2, true, 3],
              ["Credit check", "credit.check", 8, 0.1, 0.2, false, 1],
              ["Manual review", "manual.review", 1, 1, 1.5, false, 1],
              ["Application confirmed", "application.confirmed", 1, 1, 2, false, 1],
              ["Customer registered online", "customer.registered", 1, 0.5, 1, false, 1],
              ["Account accessed", "account.accessed", 1, 0.5, 1],
            ]

            // Which of the steps would you like to be optional?
            // First number: The "0 indexed" step number (for example step 6 is step 5).
            // Second number: Percentage of flows that will do this step. e.g. 40 = 40% of users will do it.
            // NB - So far only tested on steps that are NOT the first or last.
            const OPTIONAL_STEP = [3, 40]

            // Locations you wish to be attached to the users, the number after it
            // is the percentage that will have that location - they must add up to 100.
            const LOCATIONS_WITH_PERCENTAGE = [
              ["London", 25],
              ["Manchester", 20],
              ["Birmingham", 12],
              ["Newcastle", 10],
              ["Glasgow", 8],
              ["Portsmouth", 7],
              ["Reading", 6],
              ["Leicester", 5],
              ["Liverpool", 4],
              ["Leeds", 3],
            ]

            // Which steps would you like to have location data attached to?
            // This is also "0 indexed" - so step 0 is the first step.
            const LOCATIONS = [0, 1]

            // Add in a custom user segment, and which steps you would like to contain the data.
            // String: Name of the field to be added to the Biz Event.
            // Array: List of steps you would like to have the segment data attached to.
            const SEGMENT = ["account.type", [0, 4, 5, 6]]

            // Different values to be used for your segment. A list of values with the
            // number representing what percentage of users will have it. They must all add
            // up to 100.
            const SEGMENTS = [
              ["personal", 60],
              ["joint", 20],
            ]

            // Add in a revenue field used to attach the monetary value to a Biz Event.
            // String: Name of the field to be added to the Biz Event.
            // Array: List of steps you would like to have the revenue data attached to.
            // First number: Minimum value.
            // Second number: Maximum value.
            // String: The "pretty name" of the revenue field.
            const REVENUE = ["account.fee", [0], 50, 100, "Account fee"]

            // Hosts from your environment that you can randomly attribute to Biz Events, you need to
            // use the Dynatrace identifier and make sure the percentages add up to 100.
            const HOST_ENTITY = [
              ["HOST-218FBE0DE60A5B16", 50],
              ["HOST-DA9370FA4A602E97", 50],
            ]

            // Different errors that you want to attach to a certain step:
            // - First field is the name of the error which will be appeneded to the step name.
            // - Second field is the (zero indexed) step this error will happen on.
            // - Third field is the percentage of time this error will happen. (which is only used in newly generated data)
            // For this first batch of data, anything in the last 2 hours will be a guaranteed error.
            const ERRORS_WITH_PERCENTAGE = [["documents.corrupt", 1, 10]]

            // Distribute the load by the time of day, by default the "peak" is around midday
            // - First field is the hour of the day, so 0 being midnight.
            // - Second field is the percentage distribution.
            // As usual, all percentages must add up to 100.
            const TIMES_OF_DAY = [
              [0, 1],
              [1, 1],
              [2, 1],
              [3, 1],
              [4, 2],
              [5, 3],
              [6, 3],
              [7, 4],
              [8, 6],
              [9, 9],
              [10, 9],
              [11, 10],
              [12, 10],
              [13, 9],
              [14, 9],
              [15, 6],
              [16, 4],
              [17, 3],
              [18, 3],
              [19, 2],
              [20, 1],
              [21, 1],
              [22, 1],
              [23, 1],
            ]

            const VARIABLES = {
              EVENT_PROVIDER: EVENT_PROVIDER,
              PROCESS_STEPS: PROCESS_STEPS,
              LOCATIONS_WITH_PERCENTAGE: LOCATIONS_WITH_PERCENTAGE,
              SEGMENT: SEGMENT,
              SEGMENTS: SEGMENTS,
              HOST_ENTITY: HOST_ENTITY,
              CORRELATION_ID: CORRELATION_ID,
              ERRORS_WITH_PERCENTAGE: ERRORS_WITH_PERCENTAGE,
              TIMES_OF_DAY: TIMES_OF_DAY,
              FLOW_NAME: FLOW_NAME,
              REVENUE: REVENUE,
              LOCATIONS: LOCATIONS,
              OPTIONAL_STEP: OPTIONAL_STEP,
              EXAMPLE_DASHBOARD: EXAMPLE_DASHBOARD,
            }

            return VARIABLES
          }
      position:
        x: 0
        y: 1
      predecessors: []
    generate_new_data:
      name: generate_new_data
      description: Build a custom task running js Code
      action: dynatrace.automations:run-javascript
      active: true
      input:
        script: >
          // Numbers for reference

          const MS_IN_S = 1000

          const MS_IN_MINUTE = 60 * MS_IN_S

          const MS_IN_HOUR = 60 * MS_IN_MINUTE

          const MS_IN_DAY = 24 * MS_IN_HOUR


          export default async function ({ execution_id }) {
            // Variable declaration
            const configGet = await fetch(
              `/platform/automation/v1/executions/${execution_id}/tasks/config/result`
            )
            const configBody = await configGet.json()

            const EVENT_PROVIDER = configBody["EVENT_PROVIDER"]
            const PROCESS_STEPS = configBody["PROCESS_STEPS"]
            const LOCATIONS_WITH_PERCENTAGE = configBody["LOCATIONS_WITH_PERCENTAGE"]
            const SEGMENT_INDEX = configBody["SEGMENT"][1]
            const SEGMENT_NAME = configBody["SEGMENT"][0]
            const SEGMENTS = configBody["SEGMENTS"]
            const HOST_ENTITY = configBody["HOST_ENTITY"]
            const CORRELATION_ID = configBody["CORRELATION_ID"]
            const ERRORS_WITH_PERCENTAGE = configBody["ERRORS_WITH_PERCENTAGE"]
            const TIMES_OF_DAY = configBody["TIMES_OF_DAY"]
            const LOCATIONS = configBody["LOCATIONS"]
            const REVENUE_NAME = configBody["REVENUE"][0]
            const REVENUE_INDEX = configBody["REVENUE"][1]
            const REVENUE_MIN = configBody["REVENUE"][2]
            const REVENUE_MAX = configBody["REVENUE"][3]
            const OPTIONAL_STEP = configBody["OPTIONAL_STEP"]

            // Function for getting random values with probabilities (which is why we have all the numbers
            // stacked up in the arrays above)
            const getRandomWithProbability = (array) => {
              const filled = array.flatMap(([value, prob]) =>
                Array.from({ length: prob }).fill(value)
              )
              const random = Math.floor(Math.random() * filled.length)
              return filled[random]
            }

            // Function to check if we need to throw an error for a given event
            const checkIfError = (step) => {
              var isError = false
              var errorName = ""
              ERRORS_WITH_PERCENTAGE.forEach((item) => {
                if (step == item[1] && getRandomInt([1, 100]) < item[2]) {
                  isError = true
                  errorName = item[0]
                }
              })

              const errorResult = {
                isError: isError,
                errorName: errorName,
              }

              return errorResult
            }

            //Function for getting a random value from an array
            const getRandomFromArray = (array) =>
              array[Math.floor(Math.random() * array.length)]

            // Function for getting a random number between 2 integers
            // The maximum is exclusive and the minimum is inclusive
            const getRandomInt = ([min, max]) =>
              Math.floor(Math.random() * (max - min) + min)

            const addExtraAttributes = (index, event) => {
              // Do we add a location?
              if (LOCATIONS.includes(index) == true) {
                event["location"] = LOCATION
              }

              // Do we add a segment?
              if (SEGMENT_INDEX.includes(index) == true) {
                event[SEGMENT_NAME] = SEGMENT
              }

              // Do we add revenue?
              if (REVENUE_INDEX.includes(index) == true) {
                event[REVENUE_NAME] = getRandomInt([REVENUE_MIN, REVENUE_MAX])
              }

              return event
            }

            const checkIfOptional = (index) => {
              if (OPTIONAL_STEP.includes(index) == true) {
                return OPTIONAL_STEP[1]
              } else {
                return false
              }
            }

            const checkIfLoop = (index) => {
              if (PROCESS_STEPS[index][5] == true) {
                return PROCESS_STEPS[index][6]
              } else {
                return false
              }
            }

            const now = new Date()
            const nowMinusTwentyFourH = now - (MS_IN_DAY - 300000)
            const nowMinusFiveM = now - MS_IN_MINUTE * 5
            const nowMinusTwoH = now - MS_IN_HOUR * 2
            const nowPlusTenM = new Date(now + MS_IN_MINUTE * 10)

            let flows = []

            // Run through and create up to 2 events every 5 minutes - this should produce a similar
            // load profile to carry on what the "data generator" did
            for (let i = 0; i < 5; i++) {
              // Based on the time of day, choose if an event is going to get generated
              var rollRandom = getRandomInt([0, 100])
              var makeNewEvent = TIMES_OF_DAY[now.getHours()][1] * 10

              if (rollRandom < makeNewEvent) {
                // Set the high level attributes which will apply across all events
                // Start time is set here for the first event, then all others are relative to this
                var LOCATION = getRandomWithProbability(LOCATIONS_WITH_PERCENTAGE)
                var UID = crypto.randomUUID()
                var SEGMENT = getRandomWithProbability(SEGMENTS)
                var HOST = getRandomWithProbability(HOST_ENTITY)
                var START_TIME = new Date(
                  nowMinusTwentyFourH +
                    getRandomInt([1, now.getTime() - nowMinusTwentyFourH])
                )
                START_TIME.setHours(getRandomWithProbability(TIMES_OF_DAY))

                // If the start time has a chance of being slightly later this hour, then
                // wind it back 24 hours
                if (START_TIME.getHours() > now.getHours()) {
                  START_TIME = new Date(START_TIME - MS_IN_DAY)
                }

                // Keep going until the start time falls in the desired range
                while (START_TIME > now || START_TIME < nowMinusFiveM) {
                  START_TIME = new Date(
                    nowMinusTwentyFourH + getRandomInt([1, now - nowMinusTwentyFourH])
                  )

                  if (START_TIME.getHours() > now.getHours()) {
                    START_TIME = START_TIME - MS_IN_DAY
                  }
                }

                var stop = false

                // Loop through every step that you've defined, checks will be made for:
                // 1. Do we need to "drop off" based on the probability you defined
                // 2. Do we need to "throw an error" based on the errors defined above and stop
                PROCESS_STEPS.forEach((item, index) => {
                  // If it's the first step, run this loop
                  if (index == 0) {
                    var event = {
                      "event.provider": EVENT_PROVIDER,
                      "event.type": item[1],
                      [CORRELATION_ID]: UID,
                      "dt.entity.host": HOST,
                      timestamp: START_TIME,
                    }

                    addExtraAttributes(index, event)

                    stop = false

                    flows.push(event)
                  }

                  // If it's the second step, run this loop
                  // Where an event is in the future it will be put under the same event.provider with
                  // ".temp" added to the end and be picked up by the "follow-uper" when the right time comes
                  else if (
                    index > 0 &&
                    getRandomInt([0, 100]) > PROCESS_STEPS[index][2] &&
                    stop == false
                  ) {
                    START_TIME = new Date(
                      START_TIME.getTime() +
                        getRandomInt([
                          PROCESS_STEPS[index][3] * MS_IN_HOUR,
                          PROCESS_STEPS[index][4] * MS_IN_HOUR,
                        ])
                    )

                    if (START_TIME < now) {
                      var eventType = item[1]
                      stop = false

                      var errorState = checkIfError(index)

                      if (START_TIME > nowMinusTwoH && errorState["isError"] == true) {
                        eventType = item[1] + "." + errorState["errorName"]
                        stop = true
                      } else {
                        stop = false
                      }

                      var event = {
                        "event.provider": EVENT_PROVIDER,
                        "event.type": eventType,
                        [CORRELATION_ID]: UID,
                        "dt.entity.host": HOST,
                        timestamp: START_TIME,
                      }

                      addExtraAttributes(index, event)

                      if (checkIfLoop(index) != false) {
                        var numberOfLoops = getRandomInt([1, checkIfLoop(index) + 1])
                        var timestamp

                        for (var x = 0; x < numberOfLoops; x++) {
                          var maxTime =
                            PROCESS_STEPS[index + 1][3] * MS_IN_HOUR * 0.9 +
                            START_TIME.getTime()
                          timestamp = new Date(
                            getRandomInt([6000, maxTime - START_TIME.getTime()]) +
                              START_TIME.getTime()
                          )

                          var loopEvent = {
                            "event.provider": EVENT_PROVIDER,
                            "event.type": eventType,
                            [CORRELATION_ID]: UID,
                            "dt.entity.host": HOST,
                            timestamp: timestamp.toISOString(),
                          }

                          loopEvent = addExtraAttributes(index, loopEvent)

                          if (timestamp > nowPlusTenM) {
                            console.log("It's in the future: " + UID)
                            loopEvent["timestamp"] = now.toISOString()
                            loopEvent["future.timestamp"] = timestamp.toISOString()
                            loopEvent["event.type"] = eventType
                            loopEvent["event.provider"] = EVENT_PROVIDER + ".temp"
                          }

                          flows.push(loopEvent)
                        }
                      } else if (checkIfOptional(index) == false) {
                        flows.push(event)
                      } else if (getRandomInt([0, 100]) < checkIfOptional(index)) {
                        flows.push(event)
                      }
                    } else {
                      var errorState = checkIfError(index)
                      if (errorState["isError"] == true) {
                        eventType = item[1] + "." + errorState["errorName"]
                        stop = true
                      } else {
                        eventType = item[1]
                        stop = false
                      }

                      var event = {
                        "event.provider": EVENT_PROVIDER + ".temp",
                        "event.type": eventType,
                        [CORRELATION_ID]: UID,
                        "dt.entity.host": HOST,
                        "future.timestamp": START_TIME,
                        timestamp: now.toISOString(),
                      }

                      addExtraAttributes(index, event)

                      if (checkIfLoop(index) != false) {
                        var numberOfLoops = getRandomInt([1, checkIfLoop(index) + 1])
                        var timestamp

                        for (var x = 0; x < numberOfLoops; x++) {
                          var maxTime =
                            PROCESS_STEPS[index + 1][3] * MS_IN_HOUR * 0.9 +
                            START_TIME.getTime()
                          timestamp = new Date(
                            getRandomInt([6000, maxTime - START_TIME.getTime()]) +
                              START_TIME.getTime()
                          )

                          var loopEvent = {
                            "event.provider": EVENT_PROVIDER + ".temp",
                            "event.type": eventType,
                            [CORRELATION_ID]: UID,
                            "dt.entity.host": HOST,
                            timestamp: now.toISOString(),
                            "future.timestamp": timestamp.toISOString(),
                          }

                          loopEvent = addExtraAttributes(index, loopEvent)

                          flows.push(loopEvent)
                        }
                      } else if (checkIfOptional(index) == false) {
                        flows.push(event)
                      } else if (getRandomInt([0, 100]) < checkIfOptional(index)) {
                        flows.push(event)
                      }
                    }
                  } else {
                    stop = true
                  }
                })
              }
            }

            console.log(
              "Sending generated events via API for " +
                flows.length +
                " flows, size: " +
                new Blob([JSON.stringify(flows)]).size +
                " bytes."
            )

            const result = await fetch(
              "/platform/classic/environment-api/v2/bizevents/ingest",
              {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(flows),
              }
            )

            console.log("Response from API call:")
            console.log(result)

            return JSON.stringify(flows)
          }
      position:
        x: 0
        y: 2
      predecessors:
        - config
      conditions:
        states:
          config: OK
    check_if_data_exists:
      name: check_if_data_exists
      description: Executes DQL query
      action: dynatrace.automations:execute-dql-query
      active: true
      input:
        query: |-
          fetch bizevents
          | filter event.provider == "{{result('config').EVENT_PROVIDER}}"
      position:
        x: -1
        y: 2
      predecessors:
        - config
      conditions:
        states:
          config: OK
    generate_historical_data:
      name: generate_historical_data
      description: Build a custom task running js Code
      action: dynatrace.automations:run-javascript
      active: true
      input:
        script: >
          import { execution } from "@dynatrace-sdk/automation-utils"


          export default async function ({ execution_id }) {
            // Variable declaration
            const configGet = await fetch(
              `/platform/automation/v1/executions/${execution_id}/tasks/config/result`
            )
            const configBody = await configGet.json()

            const EVENT_PROVIDER = configBody["EVENT_PROVIDER"]
            const PROCESS_STEPS = configBody["PROCESS_STEPS"]
            const LOCATIONS_WITH_PERCENTAGE = configBody["LOCATIONS_WITH_PERCENTAGE"]
            const SEGMENT_INDEX = configBody["SEGMENT"][1]
            const SEGMENT_NAME = configBody["SEGMENT"][0]
            const SEGMENTS = configBody["SEGMENTS"]
            const HOST_ENTITY = configBody["HOST_ENTITY"]
            const CORRELATION_ID = configBody["CORRELATION_ID"]
            const ERRORS_WITH_PERCENTAGE = configBody["ERRORS_WITH_PERCENTAGE"]
            const TIMES_OF_DAY = configBody["TIMES_OF_DAY"]
            const LOCATIONS = configBody["LOCATIONS"]
            const REVENUE_NAME = configBody["REVENUE"][0]
            const REVENUE_INDEX = configBody["REVENUE"][1]
            const REVENUE_MIN = configBody["REVENUE"][2]
            const REVENUE_MAX = configBody["REVENUE"][3]
            const OPTIONAL_STEP = configBody["OPTIONAL_STEP"]

            // Check if data exists already - if it does, don't run this again
            const historyGet = await fetch(
              `/platform/automation/v1/executions/${execution_id}/tasks/check_if_data_exists/result`
            )
            const historyBody = await historyGet.json()
            var historyCheck = true

            if (
              historyBody.records.length == 0 ||
              historyBody.records.length == undefined
            ) {
              historyCheck = false
            } else {
              historyCheck = true
            }

            // Override if needed, set this to "false" if you need to get more historical data
            // for any reason
            //historyCheck = false;

            // Numbers for reference
            const MS_IN_S = 1000
            const MS_IN_MINUTE = 60 * MS_IN_S
            const MS_IN_HOUR = 60 * MS_IN_MINUTE
            const MS_IN_DAY = 24 * MS_IN_HOUR

            // Function for getting random values with probabilities (which is why we have all the numbers
            // stacked up in the arrays above)
            const getRandomWithProbability = (array) => {
              const filled = array.flatMap(([value, prob]) =>
                Array.from({ length: prob }).fill(value)
              )
              const random = Math.floor(Math.random() * filled.length)
              return filled[random]
            }

            // Function to check if we need to throw an error for a given event
            const checkIfError = (step) => {
              var isError = false
              var errorName = ""
              ERRORS_WITH_PERCENTAGE.forEach((item) => {
                if (step == item[1]) {
                  isError = true
                  errorName = item[0]
                }
              })

              const errorResult = {
                isError: isError,
                errorName: errorName,
              }

              return errorResult
            }

            //Function for getting a random value from an array
            const getRandomFromArray = (array) =>
              array[Math.floor(Math.random() * array.length)]

            // Function for getting a random number between 2 integers
            // The maximum is exclusive and the minimum is inclusive
            const getRandomInt = ([min, max]) =>
              Math.floor(Math.random() * (max - min) + min)

            const addExtraAttributes = (index, event) => {
              // Do we add a location?
              if (LOCATIONS.includes(index) == true) {
                event["location"] = LOCATION
              }

              // Do we add a segment?
              if (SEGMENT_INDEX.includes(index) == true) {
                event[SEGMENT_NAME] = SEGMENT
              }

              // Do we add revenue?
              if (REVENUE_INDEX.includes(index) == true) {
                event[REVENUE_NAME] = getRandomInt([REVENUE_MIN, REVENUE_MAX])
              }

              return event
            }

            const checkIfOptional = (index) => {
              if (OPTIONAL_STEP.includes(index) == true) {
                return OPTIONAL_STEP[1]
              } else {
                return false
              }
            }

            const checkIfLoop = (index) => {
              if (PROCESS_STEPS[index][5] == true) {
                return PROCESS_STEPS[index][6]
              } else {
                return false
              }
            }

            const now = new Date()
            const nowMinusTwentyFourH = now - (MS_IN_DAY - 300000)
            const nowMinusTwoH = now - MS_IN_HOUR * 2
            const nowPlusTenM = new Date(now + MS_IN_MINUTE * 10)

            console.log(nowMinusTwoH)
            console.log(nowPlusTenM)

            let flows = []

            // Run through and create 500 events over the last 24 hours
            // If you alter this, make sure to alter the "follow-uper"
            if (historyCheck == false) {
              console.log(
                "No existing events detected - generating data for last 24 hours."
              )

              for (let i = 0; i < 500; i++) {
                // Set the high level attributes which will apply across all events
                // Start time is set here for the first event, then all others are relative to this
                var LOCATION = getRandomWithProbability(LOCATIONS_WITH_PERCENTAGE)
                var UID = crypto.randomUUID()
                var SEGMENT = getRandomWithProbability(SEGMENTS)
                var HOST = getRandomWithProbability(HOST_ENTITY)
                var START_TIME = new Date(
                  nowMinusTwentyFourH +
                    getRandomInt([1, now.getTime() - nowMinusTwentyFourH])
                )
                START_TIME.setHours(getRandomWithProbability(TIMES_OF_DAY))

                // If the start time has a chance of being slightly later this hour, then
                // wind it back 24 hours
                if (START_TIME.getHours() > now.getHours()) {
                  START_TIME = new Date(START_TIME - MS_IN_DAY)
                }

                // Keep going until the start time falls in the desired range
                while (START_TIME > now || START_TIME < nowMinusTwentyFourH) {
                  START_TIME = new Date(
                    nowMinusTwentyFourH + getRandomInt([1, now - nowMinusTwentyFourH])
                  )

                  if (START_TIME.getHours() > now.getHours()) {
                    START_TIME = START_TIME - MS_IN_DAY
                  }
                }

                var stop = false

                // Loop through every step that you've defined, checks will be made for:
                // 1. Do we need to "drop off" based on the probability you defined
                // 2. Do we need to "throw an error" based on the errors defined above and stop
                PROCESS_STEPS.forEach((item, index) => {
                  // If it's the first step, run this loop
                  if (index == 0) {
                    var event = {
                      "event.provider": EVENT_PROVIDER,
                      "event.type": item[1],
                      [CORRELATION_ID]: UID,
                      "dt.entity.host": HOST,
                      timestamp: START_TIME,
                    }

                    addExtraAttributes(index, event)

                    stop = false

                    flows.push(event)
                  }

                  // If it's the second step, run this loop
                  // Where an event is in the future it will be put under the same event.provider with
                  // ".temp" added to the end and be picked up by the "follow-uper" when the right time comes
                  else if (
                    index > 0 &&
                    getRandomInt([0, 100]) > PROCESS_STEPS[index][2] &&
                    stop == false
                  ) {
                    START_TIME = new Date(
                      START_TIME.getTime() +
                        getRandomInt([
                          PROCESS_STEPS[index][3] * MS_IN_HOUR,
                          PROCESS_STEPS[index][4] * MS_IN_HOUR,
                        ])
                    )

                    if (START_TIME < now) {
                      var eventType = item[1]
                      stop = false

                      if (
                        START_TIME > nowMinusTwoH &&
                        checkIfError(index)["isError"] == true
                      ) {
                        eventType = item[1] + "." + checkIfError(index)["errorName"]
                        stop = true
                      }

                      var event = {
                        "event.provider": EVENT_PROVIDER,
                        "event.type": eventType,
                        [CORRELATION_ID]: UID,
                        "dt.entity.host": HOST,
                        timestamp: START_TIME,
                      }

                      addExtraAttributes(index, event)

                      if (checkIfLoop(index) != false) {
                        var numberOfLoops = getRandomInt([1, checkIfLoop(index) + 1])
                        var timestamp

                        for (var x = 0; x < numberOfLoops; x++) {
                          var maxTime =
                            PROCESS_STEPS[index + 1][3] * MS_IN_HOUR * 0.9 +
                            START_TIME.getTime()
                          timestamp = new Date(
                            getRandomInt([6000, maxTime - START_TIME.getTime()]) +
                              START_TIME.getTime()
                          )

                          var loopEvent = {
                            "event.provider": EVENT_PROVIDER,
                            "event.type": eventType,
                            [CORRELATION_ID]: UID,
                            "dt.entity.host": HOST,
                            timestamp: timestamp.toISOString(),
                          }

                          loopEvent = addExtraAttributes(index, loopEvent)

                          if (timestamp > nowPlusTenM) {
                            loopEvent["timestamp"] = now.toISOString()
                            loopEvent["future.timestamp"] = timestamp.toISOString()
                            loopEvent["event.type"] = eventType
                            loopEvent["event.provider"] = EVENT_PROVIDER + ".temp"
                          }

                          flows.push(loopEvent)
                        }
                      } else if (checkIfOptional(index) == false) {
                        flows.push(event)
                      } else if (getRandomInt([0, 100]) < checkIfOptional(index)) {
                        flows.push(event)
                      }
                    } else {
                      var event = {
                        "event.provider": EVENT_PROVIDER + ".temp",
                        "event.type": item[1],
                        [CORRELATION_ID]: UID,
                        "dt.entity.host": HOST,
                        "future.timestamp": START_TIME,
                        timestamp: now.toISOString(),
                      }

                      addExtraAttributes(index, event)

                      if (checkIfLoop(index) != false) {
                        var numberOfLoops = getRandomInt([1, checkIfLoop(index) + 1])
                        var timestamp

                        for (var x = 0; x < numberOfLoops; x++) {
                          var maxTime =
                            PROCESS_STEPS[index + 1][3] * MS_IN_HOUR * 0.9 +
                            START_TIME.getTime()
                          timestamp = new Date(
                            getRandomInt([6000, maxTime - START_TIME.getTime()]) +
                              START_TIME.getTime()
                          )

                          var loopEvent = {
                            "event.provider": EVENT_PROVIDER,
                            "event.type": eventType,
                            [CORRELATION_ID]: UID,
                            "dt.entity.host": HOST,
                            timestamp: now.toISOString(),
                            "future.timestamp": timestamp.toISOString(),
                          }

                          loopEvent = addExtraAttributes(index, loopEvent)

                          flows.push(loopEvent)
                        }
                      } else if (checkIfOptional(index) == false) {
                        flows.push(event)
                      } else if (getRandomInt([0, 100]) < checkIfOptional(index)) {
                        flows.push(event)
                      }
                    }
                  } else {
                    stop = true
                  }
                })
              }
              //Send all the events into the BizEvents API

              console.log(
                "Sending generated events via API for " +
                  flows.length +
                  " flows, size: " +
                  new Blob([JSON.stringify(flows)]).size +
                  " bytes."
              )

              const result = await fetch(
                "/platform/classic/environment-api/v2/bizevents/ingest",
                {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify(flows),
                }
              )

              console.log("Response from API call:")
              console.log(result)
            } else {
              console.log("Data already exists, skipping data generation.")
            }

            return JSON.stringify(flows)
          }
      position:
        x: -1
        y: 3
      predecessors:
        - check_if_data_exists
      conditions:
        states:
          check_if_data_exists: OK
    process_temporary_events:
      name: process_temporary_events
      description: Build a custom task running js Code
      action: dynatrace.automations:run-javascript
      active: true
      input:
        script: >
          // Import of required SDK modules

          import { execution } from "@dynatrace-sdk/automation-utils"

          import { queryExecutionClient } from "@dynatrace-sdk/client-query"


          // Numbers for reference

          const MS_IN_S = 1000

          const MS_IN_MINUTE = 60 * MS_IN_S

          const MS_IN_HOUR = 60 * MS_IN_MINUTE

          const MS_IN_DAY = 24 * MS_IN_HOUR


          export default async function ({ execution_id }) {
            // Variable declaration
            const configGet = await fetch(
              `/platform/automation/v1/executions/${execution_id}/tasks/config/result`
            )
            const configBody = await configGet.json()

            const EVENT_PROVIDER = configBody["EVENT_PROVIDER"]
            const PROCESS_STEPS = configBody["PROCESS_STEPS"]
            const CORRELATION_ID = configBody["CORRELATION_ID"]
            const OPTIONAL_STEP = configBody["OPTIONAL_STEP"][0]

            const ex = await execution(execution_id)

            // Get the details about what the time is now, we'll use this to calculate
            // the sliding window that we need to create
            const now = new Date()
            const currentS = now.getSeconds()
            const currentMs = now.getMilliseconds()

            // Create a start timestamp which is 6 minutes ago, and a finish timestamp which is
            // 1 minute ago (shifted to take off extra seconds/milliseconds)
            const start = now - currentS * MS_IN_S - currentMs - 360 * MS_IN_S
            const finish = now - currentS * MS_IN_S - currentMs - 60 * MS_IN_S

            // Query to check in this sliding window for events which need to be processed
            // into "permanent" from the ".temp" provider
            var query =
              'fetch bizevents, from:-30d | filter event.provider == "' +
              EVENT_PROVIDER +
              '.temp" | filter toTimestamp(future.timestamp) > toTimestamp(' +
              start * 1000000 +
              ") AND toTimestamp(future.timestamp) < toTimestamp(" +
              finish * 1000000 +
              ")"

            console.log(query)

            // Execute the query and get the results back
            const queryTempRecords = await queryExecutionClient.queryExecute({
              body: {
                query,
                requestTimeoutMilliseconds: 60 * 1000,
                fetchTimeoutSeconds: 60,
              },
            })
            const records = queryTempRecords.result.records

            var events = []
            var timestamp = ""
            const nowMinusTwentyFourH = now - (MS_IN_DAY - 300000)

            var filterText = "| filter in(" + CORRELATION_ID

            console.log(records)

            // Loop through each of the records and create the permanent event ready to be sent
            records.forEach((item) => {
              filterText = filterText + ',"' + item[CORRELATION_ID] + '"'

              var futureTimestamp = new Date(item["future.timestamp"])

              // If the future timestamp attribute is less than 24 hours ago and less than now, then
              // continue because the API will take it
              if (futureTimestamp > nowMinusTwentyFourH && futureTimestamp < now) {
                // Replace the timestamp with the "future timestamp" we gave it and
                // remove unwanted fields
                timestamp = item["future.timestamp"]
                item["timestamp"] = timestamp
                item["event.provider"] = EVENT_PROVIDER
                delete item["future.timestamp"]
                delete item["lookup.timestamp"]
                delete item["event.id"]
                delete item["event.kind"]
                delete item["dt.openpipeline.pipelines"]
                delete item["dt.openpipeline.source"]

                events.push(item)
              }
            })

            // Create a "summarize" statement used for a query below to check for missing events for specific flow.
            var summaryText = "| summarize "

            for (var i = 0; i < PROCESS_STEPS.length; i++) {
              summaryText =
                summaryText +
                PROCESS_STEPS[i][1] +
                ' = countIf(event.type == "' +
                PROCESS_STEPS[i][1] +
                '"), '
            }

            summaryText = summaryText + "by:{" + CORRELATION_ID + "}"

            // Build a statement which will summarize whether each step has been performed for a given flow.
            query =
              'fetch bizevents, from:-30d | filter event.provider == "' +
              EVENT_PROVIDER +
              '"' +
              filterText +
              ")" +
              summaryText

            console.log(query)

            const queryPreviousRecords = await queryExecutionClient.queryExecute({
              body: {
                query,
                requestTimeoutMilliseconds: 60 * 1000,
                fetchTimeoutSeconds: 60,
              },
            })
            const previousRecords = queryPreviousRecords.result.records

            console.log(previousRecords)

            var stepNumber
            var confirmedEvents = []

            // Go through each event that we've just made "permanent" and check that there's no missing steps
            // before the one that we're processing. Events without missing steps will be put into the
            // "confirmedEvents" list to be sent.
            events.forEach((item) => {
              var missingEvent = 0
              var stepIndex = 0

              for (var i = 0; i < PROCESS_STEPS.length; i++) {
                if (PROCESS_STEPS[i][1] == item["event.type"]) {
                  stepIndex = i
                }
              }

              for (var y = 0; y < previousRecords.length; y++) {
                if (previousRecords[y][CORRELATION_ID] == item[CORRELATION_ID]) {
                  for (var x = 0; x < stepIndex; x++) {
                    if (previousRecords[y][PROCESS_STEPS[x][1]] == 0) {
                      if (x != OPTIONAL_STEP) {
                        console.log("Step missing:")
                        missingEvent++
                        console.log(previousRecords[y])
                      }
                    }
                  }
                }
              }

              if (missingEvent == 0) {
                confirmedEvents.push(item)
              }
            })

            console.log(
              "Dropping " +
                (events.length - confirmedEvents.length) +
                " out of " +
                events.length +
                " events."
            )

            //Send all the new permanent events into the BizEvents API
            const result = await fetch(
              "/platform/classic/environment-api/v2/bizevents/ingest",
              {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(confirmedEvents),
              }
            )

            console.log(result)

            return JSON.stringify(confirmedEvents)
          }
      position:
        x: 1
        y: 2
      predecessors:
        - config
      conditions:
        states:
          config: OK
  description: ""
  trigger:
    schedule:
      rule: null
      trigger:
        type: interval
        intervalMinutes: 5
      timezone: Europe/London
      isActive: true
      isFaulty: false
      nextExecution: 2024-10-08T04:49:47.962Z
      filterParameters: {}
      inputs: {}
  schemaVersion: 3
